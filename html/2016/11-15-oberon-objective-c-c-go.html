<!DOCTYPE html>

<html lang="ru">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Скорость сортировки</title>

  <link rel="stylesheet" type="text/css" href="../main.css"/>
</head>

<body><h2>Скорость ООП сортировки вставками на Oberon, Objective-C, C++, Go</h2>
<style>
  td,th {
    background-color: #EEE;
  }
</style>

<p>
  Продолжаю тестировать транслятор Оберона из проекта
  <a href="https://github.com/Vostok-space/vostok">"Восток"</a>.
  На сей раз мой взор пал на производительность при использовании объектно ориентированного подхода.
  Ранее я уже проводил  
  <a href="http://comdivbyzero.blogspot.com/2013/03/c-objective-c-c.html">сравнение для Си, Objective-C, C++</a>
  на примере сортировки вставками. Недостатком того воплощения было то, что в нём испытывался только вызов виртуального метода, а безопасного приведения от общего типа к расширенному не было. Для Си это требовало написания большего количества текста, чем нужно, поэтому и для остальных языков оно было исключено. Теперь, когда у меня есть транслятор Оберона в Си, эту возможность задействовать куда проще, поэтому я соответствующим образом подправил тест, также заменив Си на Оберон.</p> 

<p>Результаты интересные, судите сами.</p>

<!--more-->

Показатели для С++ и Objective-C и Go поделены на соответствующие показатели для Оберона 
<table><tbody><tr><td>Язык</td><td>С++</td><td>Objective-C</td><td>Go</tr><tr><td>Время работы</td><td>4,34</td><td>3,93</td><td>3,24</tr><tr><td>Размер исходников</td><td>0,85</td><td>1,07</td><td>0,56</tr><tr><td>Размер исполнимого файла</td><td>1</td><td>1,16</td><td>153</tr></tbody></table>

<p>Не так смешно, что код на С++, в котором реализовано множественное наследование, уступил по скорости Оберону, в котором запись может быть расширена от единственной базовой, как то, что С++ оказался даже медленней обычно более тормозного Objective-C, чьё ООП построено на более мудрёном механизме посылки сообщений. Справедливости ради надо отметить, что такого результата удалось добиться вынесением получения класса от приводимого типа за цикл, что в обычном случае не делается. То есть, вместо </p> 
<pre><code>assert([ia isKindOfClass:[IntPoint class]]);</code></pre>
использовалось
<pre><code>assert([ia isKindOfClass:IntPointClass]);</code></pre>где <code>IntPointClass<code/>
  - это глобальная переменная, инициализированная значением 
  <code>[IntPoint class]</code>. 
<p> Без этого программа работала в 3 раза медленней.</p> 


Так как меня интересовала только скорость ООП, то остальные проверки были отключены для всех языков, кроме Go, для которого я не знаю простого способа сделать это. Тем не менее, Go показал лучший после Оберона результат. Для сборки Go использовался go version 1.6.2, для трансляции остальных языков использовался <code>gcc version 5.4</code> с ключами оптимизации <code>-O3 -flto</code>.  Полный код теста, как всегда, доступен на 
<a href="https://github.com/ComdivByZero/test-ext-oop-insert-sort-efficiency">github</a>.  

<p><b>Обновление</b>: проверил тест на Orange Pi PC+ - одноплатном миникомпьютере. На нём стоит Debian Jessie от Armbian c более старыми версиями компиляторов, что вкупе с другой архитектурой процессора перевернуло места за исключением нетронутого лидера на Oberon: 
</p>

<table><tbody><tr><td>Язык                    </td><td>С++ </td><td>Objective-C</td><td>Go  </tr><tr><td>Время работы            </td><td>3,24</td><td>4,56       </td><td>4,7 </tr><tr><td>Размер исходников       </td><td>0,85</td><td>1,07       </td><td>0,56</tr><tr><td>Размер исполнимого файла</td><td>0,99</td><td>2,42       </td><td>176 </tr></tbody></table>Компиляторы: gcc 4.9.2, go 1.3.3. 

<p><b>2-е обновление</b>: сумел поставить на Orange Pi PC+ Ubuntu 16.04 - идентичную версию того, что стоит на основном компьютере, поэтому и версии компиляторов на них совпадают - gcc 5.4 и go 1.6.1. 
</p>

<table><tbody><tr><td>Язык                    </td><td>С++ </td><td>Objective-C</td><td>Go  </tr><tr><td>Время работы            </td><td>3,13</td><td>3,52       </td><td>3   </tr><tr><td>Размер исходников       </td><td>0,85</td><td>1,07       </td><td>0,56</tr><tr><td>Размер исполнимого файла</td><td>1,02</td><td>2,11       </td><td>201 </tr></tbody></table>
</body>
</html>
