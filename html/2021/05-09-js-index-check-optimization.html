<!DOCTYPE html>

<html lang="ru">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Оптимизация в JavaScript</title>

  <link rel="stylesheet" type="text/css" href="../main.css"/>
</head>

<body><h2>Оптимизация памяти в JavaScript при проверке индексов массивов</h2>
<p>Добавив в 
  <a href="https://github.com/Vostok-space/vostok/tree/master/test/benchmark">benchmark</a>,
  в качестве которого служит сам транслятор, исполнение версий на Java и JavaScript, обнаружил, что
  для последнего при включённых проверках индексов массивов происходит ~ 8-кратный перерасход памяти по 
  сравнению с выключенными 
  проверками, что было незаметно на небольших программах. Расход памяти, в свою очередь, приводит и к ощутимо
  большему времени исполнения, чего, опять-таки, не было в простых тестах.
</p>

<p>Перерасход был вызван, в основном, тем, что методы доступа к элементам массива находились в самом массиве, 
  что было сделано в расчёте на потенциально высокую возможность оптимизации при JIT-исполнении и без учёта влияния
  на занимаемую память. Замеры показали всё, как есть - и неоправдавшиеся надежды на оптимизации, и ужасы
  накладных расходов на сборку мусора.
</p>

<p>Оптимальным по всем параметрам 
  <a href="https://github.com/Vostok-space/vostok/commit/5f0496b122fbc9f08713524256a66d2a800c13c7">решением</a>
  оказалось добавление методов доступа непосредственно классу Array
  вместо создания дополнительных обёрток.
</p>

<p>Дополнительно в JavaScript была устранена генерация проверок индекса для простых случаев, когда статически
  известно о гарантиях корректного обращения к массиву. Также, была усовершенствована пометка переменных, которые
  участвуют в вызовах подпрограмм в качестве VAR-параметров, что в Java и JavaScript имитируется через массивы.
  Это позволило устранить превращение в массивы переменных в вызовах NEW, PACK, UNPK.
</p>

</body>
</html>
