<!DOCTYPE html>

<html lang="ru">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Экспериментальная лексика</title>

  <link rel="stylesheet" type="text/css" href="../main.css"/>
</head>

<body><h2>Экспериментальная версия лексики</h2>

<div class="separator" style="clear: both;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg7KMw0W11s4x8FLMvgezqKcyAdNGWkxgbv2t9XNj6OKB9vyK9P22J_DIa_LiZwlyYc1qO5vKGnGFmZ1Z91mMc4isd3208FLT8b2gJvLvIWR-SNsDkb-FXrj24If76IWnU-rjHPLHFSz70msEmK7GGIoBVdti_hPUd4Tr1jKDpP50GOopaZdVFiu8Uu_8A/s1024/DALL%C2%B7E%202023-11-19%2022.45.00%20-%20Abstract%20representation%20of%20a%20scientific%20experiment.%20The%20image%20should%20include%20a%20variety%20of%20symbolic%20elements%20such%20as%20test%20tubes,%20beakers,%20a%20microscope,.png" style="display: block; padding: 0 1em; text-align: center; clear: right; float: right;"><img alt="" border="0" width="320" data-original-height="1024" data-original-width="1024" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg7KMw0W11s4x8FLMvgezqKcyAdNGWkxgbv2t9XNj6OKB9vyK9P22J_DIa_LiZwlyYc1qO5vKGnGFmZ1Z91mMc4isd3208FLT8b2gJvLvIWR-SNsDkb-FXrj24If76IWnU-rjHPLHFSz70msEmK7GGIoBVdti_hPUd4Tr1jKDpP50GOopaZdVFiu8Uu_8A/s320/DALL%C2%B7E%202023-11-19%2022.45.00%20-%20Abstract%20representation%20of%20a%20scientific%20experiment.%20The%20image%20should%20include%20a%20variety%20of%20symbolic%20elements%20such%20as%20test%20tubes,%20beakers,%20a%20microscope,.png"/></a></div>

<p>В качестве эксперимента попробовал взглянуть на Оберон с совершенно другой лексикой.</p>
<p>Из особенностей можно отметить</p>

<ul>
  <li>С одной стороны большая направленность на кириллицу и набор из кириллических раскладок.</li>
  <li>С другой стороны уклон в интернационализацию с помощью значков и уменьшения зависимости от естественной лексики.</li>
  <li>И даже использование юникод-символов с целью приближения к математическим символам.</li>
  <li>Но с возможностью обойтись легкодоступными символами в альтернативном варианте.</li>
  <li>Увеличение ясности ряда элементов.</li>
</ul>

<p>ПРЕДУПРЕЖДЕНИЕ: при наличии высокой чувствительности и лёгкой травмируемости лучше избежать дальнейшего просмотра.</p>
<!--more-->

<style>
  pre, div.table, details.code {overflow: auto;}
  pre, code, .code { background-color: #F2F2F2; font-size: 14px;}
  code>em   { background-color: #FFF; }
  code      { white-space: pre; }
  pre, code {
  	font-family: "Ubuntu Mono","Söhne Mono",Monaco,Andale Mono,monospace !important;
  	font-size:16px;
  }
  td        { padding-right: 10px; font-size: 13px; vertical-align: top; }
  tr:nth-child(even) { background-color: #EAEAEA;; }
  td code   { background-color: inherit;}
</style>

<p>Такой код на Обероне:</p>
<pre><code>MODULE Parse;
 IMPORT Int := ParseIntDec;
 
 PROCEDURE InRange(pre, digit: INTEGER): BOOLEAN;
 CONST Last = (-Int.Radix - Int.Min) MOD Int.Radix;
       Cut  = ( Last      + Int.Min) DIV Int.Radix;
 BEGIN  ASSERT(pre &lt;= 0); ASSERT((0 &lt;= digit) &amp; (digit &lt; Int.Radix))
 RETURN
    (pre > Cut)
 OR (pre = Cut) &amp; (digit &lt;= Last)
 END InRange;
  
 PROCEDURE Do*(s: ARRAY OF CHAR; VAR i: INTEGER;
               VAR val: INTEGER): INTEGER;
 VAR d, ok: INTEGER; neg: BOOLEAN;
 BEGIN
  neg := s[i] = "-";
  IF neg OR (s[i] = "+") THEN INC(i) END;

  ok := Int.Digit(s[i], d);
  IF ok THEN
    val := -d;
    INC(i);
    WHILE Int.Digit(s[i], d) &amp; InRange(val, d) DO
      val := val * Int.Radix  -  d;
      INC(i)
    END;
    ok := (d &lt; 0)  &amp;  (neg OR (val >= -Int.Max));
    IF ok &amp; ~neg THEN
      val := -val
    END
  END
 RETURN ok
 END Do;

END Parse.</code></pre>

С экспериментальной лексикой может выглядеть так:

<pre><code>==== Разбор (

 ((Набор <b>←</b> ДляРазбора10й))

 == Подходит(предв, цифра: Ц) <b>→</b> врамках: П,
  !! предв ≤ 0. 
  !! 0 ≤ цифра &lt; Набор<b>`</b>Основание.
 (
  Последняя   .= (- Набор<b>`</b>Основание - Набор<b>`</b>Минимум) |÷| Набор<b>`</b>Основание.
  МаксБезПосл .= (Последняя           + Набор<b>`</b>Минимум)  ÷  Набор<b>`</b>Основание.

  врамках =  (предв > МаксБезПосл)  
          ∨  (предв = МаксБезПосл) ∧ (цифра ≤ Последняя)
 ).

 == +Дай(стр: [×Л]; <b>↔</b> инд, <b>→</b> знач: Ц) <b>→</b> ух: П,    !! 0 ≤ инд &lt; ДЛИНА(стр). (
  цифра: Ц.  минус: П.

  минус = стр[инд] = '-'.
  ??  минус ∨ (стр[инд] = '+')  (
    инд + 1
  ).

  ух <b>←</b> Набор<b>`</b>Цифра(стр[инд], <b>→</b> знач).
  ??  ух  (
    знач <b>←</b> - знач.
    инд + 1.
    (↺)  Набор<b>`</b>Цифра(стр[инд], <b>→</b> цифра) ∧ Подходит(знач, цифра)  (
      знач <b>←</b> знач ⋅ Набор<b>`</b>Основание  -  цифра.
      инд + 1
    ).
    ух = (цифра &lt; 0) ∧ (отр ∨ (знач ≥ - Набор<b>`</b>Максимум)).
    
    ??  ух ∧ ¬минус  (
      знач = - знач
    )
  )
 ) Дай.

) Разбор.</code></pre>
<br/>

<p>Таблица соответствия между кодом на привычной лекскике Оберона и экспериментальной.</p>
<div class='table'>
<table>
  <tr>
    <th>Oberon</th>
    <th>Эксперимент</th>
  </tr>
  <tr>
    <td><code>1000000</code></td>
    <td><code>1<b>`</b>000<b>`</b>000
1 000 000</code></td>
    <td>Десятичное число.<br/>
    Неправильно:
      <code>100 0000</code>
    </td>
  </tr>
  <tr>
    <td><code>4ABCDEFH</code></td>
    <td><code>04НЕ<b>`</b>ДТКПш
04НЕ ДТКП ш</code></td>
    <td>Мнемоника для шестнадцатеричных:
      <code>10 = 10 + <b>Н</b>оль
11 = 10 + <b>Е</b>диница (О ~ 0)
12 = 10 + <b>Д</b>войка
13 = 10 + <b>Т</b>ройка
14 = 10 + <b>К</b>варта (Ч ~ 4)
15 = 10 + <b>П</b>ятёрка</code></td>
  </tr>
  <tr>
    <td><code>7FH</code></td>
    <td><code>7Пш
007Пш</code></td>
    <td>Неправильно: <code>07Пш , 7П</code></td>
  </tr>
  <tr>
    <td><code>1000.0001</code></td>
    <td><code>1<b>`</b>000,000<b>`</b>10
1 000,000 10</code></td>
    <td>Точное значение дроби</td>
  </tr>
  <tr>
    <td><code>2.718281828459045</code></td>
    <td><code>2,718<b>`</b>281<b>`</b>828<b>`</b>459<b>`</b>045…
2,718 281 828 459 045_</code></td>
    <td>Приблизительное значение дроби</td>
  </tr>
  
  <tr>
    <td><code>{1..4}</code></td>
    <td><code>{1..4}
(/1..4)</code></td>
    <td></td>
  </tr>  
  <tr>
    <td><code>{}</code></td>
    <td><code>{}
(/)
∅</code></td>
    <td></td>
  </tr>  
  <tr>
    <td><code>TRUE</code></td>
    <td><code>ДА</code></td>
  </tr>
  <tr>
    <td><code>FALSE</code></td>
    <td><code>НЕТ</code></td>
  </tr>
  <tr>
    <td><code>NIL</code></td>
    <td><code>()</code></td>
  </tr>
  <tr>
    <td><code>BOOLEAN</code></td>
    <td><code>П</code></td>
    <td>Простейший, примитивный</td>
  </tr>
  <tr>
    <td><code>INTEGER</code></td>
    <td><code>Ц</code></td>
    <td>Целое</td>
  </tr>
  <tr>
    <td><code>REAL</code></td>
    <td><code>Д</code></td>
    <td>Дробь</td>
  </tr>
  <tr>
    <td><code>CHAR</code></td>
    <td><code>Л</code></td>
    <td>Литера</td>
  </tr>
  <tr>
    <td><code>SET</code></td>
    <td><code>М</code></td>
    <td>Множество</td>
  </tr>
  <tr>
    <td><code>ARRAY Const * 3 + 4 OF CHAR</code></td>
    <td><code>Const1 .= Const * 3.
[(Const1 + 4) × Л]
 (Const1 + 4) х Л </code></td>
    <td>В задании длины запрет на умножение<br/>[] по вкусу</td>
  </tr>
  <tr>
    <td><code>ARRAY OF ARRAY OF REAL</code></td>
    <td><code>×× Д
[х х Д]</code></td>
  </tr>
  <tr>
    <td><code>Base = RECORD END;</code></td>
    <td><code>Основа = (;)</code></td>
  </tr> 
  <tr>
    <td><code>Int = RECORD(Base) 
        v: INTEGER 
      END;</code></td>
    <td><code>Цел = (: Основа; зн: Ц)</code></td>
  </tr>
  <tr>
    <td><code>POINTER TO Record</code></td>
    <td><code>(<b>↑</b>)Связка
(^)Связка
(НА)Связку</code></td>
    <td>Скобки указывают на допустимость ()-указателя как значения</td>
  </tr>
  <tr>
    <td></td>
    <td><code><b>↑</b>Связка
^Связка
НА Связку</code></td>
    <td><code> указатель ≠ ()</code></td>
  </tr>
  <tr>
    <td><code>Proc(ptr^)</code></td>
    <td><code>Дело(укз<b>↑</b>)
Дело(укз^)
Дело(укз ИЗ)</code></td>
  </tr>  
  <tr>
    <td><code>Val = POINTER TO 
      RECORD v: CHAR END;
v: Val;</code></td>
    <td><code>Зн = (; зн: Л).
зн: <b>↑</b>Зн.</code></td>
    <td>Указатель нельзя «прятать» за именем типа</td>
  </tr>
  <tr>
    <td><code>PROCEDURE Proc(input: INTEGER)
              : REAL;
RETURN 1.0 / FLT(input)
END Proc;</code></td>
    <td><code>== Дело(ввод: Ц) <b>→</b> 
        вывод: Д (
  вывод = 1.0 / (ввод:Д)
) Дело.</code></td>
  </tr>
  <tr>
    <td><code>PROCEDURE Do(OUT a: REAL; 
             VAR b: REAL);
Do(i, r)</code></td>
    <td><code>== Дей(<b>→</b> а, <b>↔</b> б: Д)
Дей(<b>→</b> а, <b>↔</b> б)
      
== Дей(-> а, &lt;-> б: Д)
Дей(->а, &lt;->б)

== Дей(В а, ИВ б: Д)
Дей(В а, ИВ б)</code></td>
  </tr> 
  <tr>
    <td><code>a[b]</code></td>
    <td><code>а[б]
а(б)</code></td>
  </tr>
  <tr>
    <td><code>Module.Declaration</code></td>
    <td><code>Раздел<b>`</b>Объявление
Раздел Объявление</code></td>
  </tr>
  <tr>
    <td><code>record.item</code></td>
    <td><code>связка<b>˙</b>часть
связка часть</code></td>
  </tr>
  <tr>
    <td><code>а # b</code></td>
    <td><code>а ≠ б
а # б
а НЕ= б</code></td>
  </tr>  
  <tr>
    <td><code>a &gt;= b</code></td>
    <td><code>а ≥ б
а &gt;= б
а Б= б
а БОЛЬШЕ= б</code></td>
  </tr>
  <tr>
    <td><code>(a &lt;= b) &amp; (b &lt; c)</code></td>
    <td><code>а ≤ б &lt; в</code></td>
  </tr>
  <tr>
    <td><code>a IN set</code></td>
    <td><code>а ∈ мнж
а ВО мнж</code></td>
  </tr>
  <tr>
    <td><code>~(a IN set)</code></td>
    <td><code>а ∉ мнж
а ВНЕ мнж</code></td>
    <td>Встречается в ~4 раза реже</td>
  </tr>
  <tr>
    <td><code>a IS Type</code></td>
    <td><code>а ЭТО Тип</code></td>
  </tr>
  <tr>
    <td><code>~(a IS Type)</code></td>
    <td><code>а НЕ Тип</code></td>
    <td>Встречается в ~10 раз реже. Может, и не нужно.</td>
  </tr>

  <tr>
    <td><code>a DIV b</code></td>
    <td><code>а ÷ б
а % б</code></td>
  </tr>
  <tr>
    <td><code>a MOD b</code></td>
    <td><code>а |÷| б
а %% б</code></td>
  </tr>
  <tr>
    <td><code>a * b</code></td>
    <td><code>а ∙ б
а * б</code></td>
  </tr>
  <tr>
    <td><code>a / b</code></td>
    <td><code>а / б</code></td>
    <td>Деление дробей</td>
  </tr>
  <tr>
    <td><code>set1 + set2</code></td>
    <td><code>мн1 ∪ мн2
мн1 + мн2</code></td>
  </tr>
  <tr>
    <td><code>set1 * set2</code></td>
    <td><code>мн1 ∩ мн2
мн1 * мн2</code></td>
  </tr>
  <tr>
    <td><code>set1 / set2</code></td>
    <td><code>мн1 ∆ мн2
мн1 / мн2</code></td>
    <td>Симметричная разница (побитовое исключительное или)</td>
  </tr>
  <tr>
    <td><code>b1 &amp; b2</code></td>
    <td><code>п1 ∧ п2
п1 /\ п2
п1 И п2</code></td>
  </tr>
  <tr>
    <td><code>b1 OR b2</code></td>
    <td><code>п1 ∨ п2
п1 \/ п2
п1 ИЛИ п2</code></td>
  </tr>
  <tr>
    <td><code>ORD(a)</code><br/><code>FLOOR(a)</code></td>
    <td><code>a:Ц</code></td>
  </tr>
  <tr>
    <td><code>CHR(a)</code></td>
    <td><code>a:Л</code></td>
  </tr>
  <tr>
    <td><code>FLT(a)</code></td>
    <td><code>a:Д</code></td>
  </tr>
  <tr>
    <td><code>ORD(a) - ORD("0")</code></td>
    <td><code>а - '0'</code></td>
  </tr>  
  <tr>
    <td><code>CHR(ORD("0") + a)</code></td>
    <td><code>'0' + а</code></td>
  </tr>
  <tr>
    <td><code>y := 1; i := n;
WHILE i > 0 DO
  IF ODD(i) THEN y := y*x END;
  x := x*x; i := i DIV 2 END</code></td>
    <td><code>а∙∙б
а**б
а<sup>б</sup></code></td>
    <td>Возведение в натуральную степень</td>
  </tr>
  <tr>
    <td><code>LSL(a, b)</code></td>
    <td><code>а ∙ 2<sup>б</sup></code></td>
  </tr>
  <tr>
    <td><code>ASR(a, b)</code></td>
    <td><code>а ÷ 2<sup>б</sup></code></td>
  </tr>
  <tr>
    <td><code>INC(a)</code></td>
    <td><code>a + 1</code></td>
  </tr> 
  <tr>
    <td><code>DEC(a)</code></td>
    <td><code>a - 1</code></td>
  </tr> 
  <tr>
    <td><code>INCL(s, 2)</code></td>
    <td><code>м + {2}</code></td>
  </tr>
  <tr>
    <td><code>EXCL(s, 3)</code></td>
    <td><code>м - {3}</code></td>
  </tr>
  <tr>
    <td><code>a := b</code></td>
    <td><code>а <b>←</b> б
а &lt;- б
а := б</code></td>
  </tr>
  <tr>
    <td><code></code></td>
    <td><code>а = б</code></td>
    <td>Текстуально последнее присваивание в текущей ветке с учётом вложенности</td>
  </tr>
  <tr>
    <td><code>t := a; a := b; b := t</code></td>
    <td><code>а <b>↔</b> б</code><br/> <code>а &lt;-> б</code><br/>
<code>а :=: б</code>
</td>
    <td>Обмен важен для поддержки уникальных указателей</td>
  </tr>
  <tr>
    <td><code>IF a THEN
  b
ELSIF c THEN
  d
ELSE
  e
END</code></td>
    <td><code>??  а  (
  б
:?  в;
  г
::
  д
)
ЕСЛИ а (
  б
ЛИБО в;
  г
ИНОЕ
  д
)</code>    
    </td>
  </tr>
  <tr>
    <td><code>CASE a OF
 1, 2: do1
|3..4: do2
END</code></td>
    <td><code>??? а (
• 1; 2: дей1
• 3..4 : дей2
🚫
)
      
??? а (
*. 1 , 2: дей1
*. 3..4 : дей2
(\)
)
      
ДЛЯ а (
В 1 , 2: дей1
В 3..4 : дей2
(-)
)</code></td>
  </tr>
  <tr>
    <td><code>WHILE a DO
  b
END</code></td>
    <td><code>(↺) а (
  б
).
      
ЦИКЛ а (
  б
).</code></td>
  </tr>
  <tr>
    <td><code>REPEAT
  a
UNTIL b;</code></td>
    <td><code>(↺) (
  а
) ¬б.
      
ЦИКЛ (
  а
) ДО б.</code></td>
  </tr>
  <tr>
    <td><code>FOR a := b TO c DO
  d
END;
FOR a := b TO LEN(c) - 1 DO
  d
END</code></td>
    <td><code>(↺) а <b>←</b> б .. в (
  г
).
ЦИКЛ а <b>←</b> б ДО ДЛИНЫ(в) (
  г
)</code></td>
  </tr>
  <tr>
    <td><code></code></td>
    <td><code></code></td>
  </tr>
</table></div>

<p>Склоняемая лексика:</p>
<pre><code>Мо-й-я: (; 
  массив: [7 x Л].
  книга: Книга
)

Мой массив[0] := 00л.
Моя книга = кн2.</code></pre>

<p>В 
  <a href="https://vostok.oberon.org/sandbox.html?view=65kdzh2jvp9m-ParseInteger">web-песочнице</a> 
  доступна трансляция из обычного кода на Обероне в код с экспериментальной лексикой при использовании 
  недокументированной команды <code>/TO-E1</code>.
</p>

Большая часть синтаксиса экспериментальной символики в РБНФ:
<details class='code'><summary>(* Лексика *)</summary>
<code>согласная = ( "Б" | "В" | "Г" | "Д" | "Ж" | "З" | "К" | "Л" | "М" | "Н" 
            | "П" | "Р" | "С" | "Т" | "Ф" | "Х" | "Ц" | "Ч" | "Ш" | "Щ"
            | "б" | "в" | "г" | "д" | "ж" | "з" | "к" | "л" | "м" | "н" 
            | "п" | "р" | "с" | "т" | "ф" | "х" | "ц" | "ч" | "ш" | "щ"
            | "Ґ" | "ґ")
            [ "Ь" | "ь"  | "Ъ" | "ъ" | "’"]
            | "Й" | "й".

гласная   = "А" | "Е" | "Ё" | "И" | "О" | "У" | "Ы" | "Э" | "Ю" | "Я"
          | "а" | "е" | "ё" | "и" | "о" | "у" | "ы" | "э" | "ю" | "я"
          | "I" | "Ї" | "Ў" | "Є"
          | "і" | "ї" | "ў" | "є".

буква     = согласная | гласная.

букваЛат  = "A" … "Z" | "a" … "z".

цифра     = "0" … "9".

цифраШес = цифра | "Н" | "Е" | "Д" | "Т" | "К" | "П".

имяРус   = буква {буква | цифра}.
имяЛат   = букваЛат {букваЛат | цифра}.
имя      = имяРус | имяЛат.

рц       = "<b>`</b>" | " ". (* разделитель цифр *)
триЦифры = цифра цифра цифра.
до3Цифр  = цифра [цифра [цифра]].
целоеДес = до3Цифр {рц триЦифры}.
целоеШес = ( цифра цифраШес
           | цифра цифраШес цифраШес цифраШес
           { рц цифраШес цифраШес цифраШес цифраШес}
           ) [" "] "ш".
целое    = целоеДес | целоеШес.

дробь    = до3Цифр {рц триЦифры } "," {триЦифры рц} до3Цифр ["…"].

число    = целое | дробь.

строка = """ {литера} """ | "«" {литера} "»" | "&lt;&lt;" {литера} ">>".
литера = цифра цифраШес [цифраШес цифраШес] "л".

умн      = "•".
возв     = "••" | "**".
дел      = "÷".
ост      = "|÷|".
откр     = "+".
мш       = "&lt;".
бш       = "&gt;".
мр       = "≤" | "&lt;=".
бр       = "≥" | ">=".
нр       = "≠" | "#".

это      = "ЭТО".
во       = "∈" | "В".
вне      = "∉" | "ВНЕ".
или      = "∨" | "\/" | "ИЛИ".
и        = "∧" | "/\" | "И".
не       = "¬" | "НЕ".

ссылка0  = "()". (* NIL, null *)
да       = "ДА".
нет      = "НЕТ".
рро      = "<b>`</b>" | " ". (* разделитель между именами раздела и объявления *)
рсп      = "<b>˙</b>" | " ". (* разделитель между именами связки и переменной *)
тт       = "..".
св       = "<b>↑</b>". (* ссылочная стрелка *)
пмн      = "∅".
обм      = "<b>↔</b>".

очередноеПрисв = "<b>←</b>".
последнееПрисв = "=".</code>
</details>

<details class='code'><summary>(* Синтаксис *)</summary>
<code>ВсёИмя            = [ имя (*раздела*)  [ рро ] ] имя (*объявления*).

ОбъявИмя          = [откр] имя.

Тип               = ВсёИмя(*типа*) | Массив | "[" Массив "]"
                  | Связка | Ссылка | Вид.
Массив            = Длина {"×" Длина} "×" Тип.
Длина             = (целое | ВсёИмя) { ("+" | "-")  (целое | ВсёИмя)}.
Связка            = "(" [":" СвязкаОснова ] ";" [Переменные] ")". (* запись, структура *)
СвязкаОснова      = ВсёИмя.
Переменные        = Поля {"." Поля}.
Поля              = ОбъявИмя {"," ОбъявИмя} ":" Тип.
СсылкаИли0        = "(<b>↑</b>)" Связка. (* Ссылка, которая может указывать на () *)
Ссылка            = "<b>↑</b>" Связка | СсылкаИли0.
Вид               = "ВИД" "(" [";"] Параметры ")" Вывод.
Параметры         = [Секция {";" Секция}].
Вывод             = ["<b>→</b>" имя ":" ВсёИмя].
ТипПар            = ["<b>→</b>" | "<b>↔</b>"].
Секция            = ТипПар имя {"," ТипПар имя ":" ФормальныйТип.
ФормальныйТип     = ({"×"} ВсёИмя | "[" "×" {"×"} ВсёИмя"]").

ОбъявПерем        = списокИмён ":" Тип.
Выражение         = Сложение [Отношение Сложение].
Отношение         = "=" | нр | мш | мр | бш | бр | (во | вне) | ( это | "НЕ" ).
Сложение          = (Слагаемое | ("+" | "-") Множитель) {ОпСложения Слагаемое}.
ОпСложения        = "+" | "-" | или.
Слагаемое         = Возведение {ОпУмножения Возведение}.
ОпУмножения       = умн | "/" | дел | ост | и.
Возведение        = Множитель <sup>Выражение</sup> | Множитель возв Множитель.
Множитель         = число | строка | ссылка0 | да | нет | Множество
                  | Обозначение [ФактическиеПараметры] | "(" Выражение ")" | не Множитель.

Обозначение       = ВсёИмя {Подчасть}.
Подчасть          = ОтСвязки | ОтМассива | ОтСсылка | Подтип.
ОтСвязки          = [рсп] имя.
ОтМассива         = "[" Индексы "]".
Индексы           = Выражение {"," Выражение}.
ОтСсылка          = св.
Подтип            = ":" ( ИмяТипа | "(" ИмяТипа ")" ).
ИмяТипа           = ВсёИмя.

Множество         = "{" [Подмножество {"," Подмножество}] "}".
Подмножество      = Выражение [тт Выражение].

ФактическиеПараметры = "(" ФактПар  {"," ФактПар} ")".
ФактПар           = [ТипПар] Обозначение | Выражение.

Оператор          = [Присваивание | Обмен | Изменение | Вызов
                  | Если | Развилка | Цикл | Провал | Пропуск].

Присваивание      = Обозначение (очередноеПрисв | последнееПрисв) Выражение
Изменение         = Обозначение ( "+" | "-" | ОпУмножения) Выражение
Обмен             = Обозначение обм Обозначение.

Вызов             = Обозначение [ФактическиеПараметры].
Операторы         = Оператор {"." Оператор}.

Если              = "??" Выражение "("
                        Операторы
                    {":?" Выражение ";"
                        Операторы      }
                    ["::"
                        Операторы ]
                    ")".

Развилка          = "???" Выражение "("
                     Ветвь
                     {Ветвь}
                     "::"
                        Операторы
                    ")".
Ветвь             = ["•" Метки ":" Операторы].
Метки             = Отрезок {"," Отрезок}.
Отрезок           = Метка [тт Метка].
Метка             = целое | литера | ВсёИмя.

Цикл              = "(↺)" Выражение "("
                            Операторы
                  { "?:" Выражение ";"
                            Операторы  }
                    ")"
                  |
                    "(↺)" "ДО" Выражение "("
                           Операторы
                     ")"
                  |
                    "(↺)" "("
                           Операторы
                    ")" [ "ДО" ] Выражение
                  |
                    "(↺)" имя очередноеПрисв Выражение ( тт | "ДО" ) 
                                 Выражение ["ПО" КонстВыражение] "("
                           Операторы
                    ")"
                  .

Провал            = "🚫"| "(\)".
Пропуск           = "_".

Дело              = ["=="] ИмяДела "(" [ФормальныеПараметры] ")" Вывод 
                    ТелоДела [ИмяДела].
ИмяДела           = имя.
ФормальныеПараметры = ГруппаПар  {";" ГруппаПар}.
ГруппаПар         = {ФормПар "," ФормПар} ":" ИмяТипа.
ФормПар           = [ТипПар] имя.
ТелоДела          = "(" Константы Типы Дела Переменные [Операторы] ")".

Константы         = {ОбъявКонст "."}.
ОбъявКонст        = ОбъявИмя ".=" КонстВыражение.
КонстВыражение    = Выражение.

Типы              = {ОбъявТип "."}.
ОбъявТип          = ОбъявИмя "=" Тип.

Дела              = {Дело "."}.

Раздел            = "====" ИмяРаздела "("
                        [Включение]
                        Константы
                        Типы
                        Дела
                        Переменные
                        ["==" "(" Операторы ")"]
                  ")" [ИмяРаздела] ".".
Включение         = "((" ВклРаздел {"," ВклРаздел} "))".
ВклРаздел         = [Переименование "="] ИмяРаздела.
Переименование    = имя.
ИмяРаздела        = имя.</code>

</details>

</body>
</html>
