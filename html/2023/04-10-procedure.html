<!DOCTYPE html>

<html lang="ru">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Процедура-модуль</title>

  <link rel="stylesheet" type="text/css" href="../main.css"/>
</head>

<body><h2>Процедура верхнего уровня</h2>
<style>
  pre, code { background-color: #EAEAEA; font-size: 14px; overflow: auto; }
  code>em   { background-color: #FFF; }
  code      { white-space: pre; }
  td        { padding-right: 10px; }
  tr:nth-child(even) { background-color: #EAEAEA;; }
  td code   { background-color: inherit; font-size: 13px;}
</style>

<p>По задумке автора Оберон лишён понятия главного модуля с главной процедурой, характерных для архитектурно устаревших операционных систем. «Точкой входа» является любая экспортированная процедура модуля без параметров, что позволяет ещё на уровне языка минимальным количеством понятий организовать более гибкое взаимодействие.</p>

<!--more-->

<p>Можно сказать, что в некоторой степени такая простота провалилась и не нашла поддержки как со стороны некоторых систем, так и какой-то части пользователей, предпочитающих использовать два вида модулей в духе Turbo Pascal, поддерживающего кодовые единицы unit и program. Но за неимением соответствующей терминологии в Oberon-системах разница между модулями выражается через неявный контекст.
</p>

<pre><code>MODULE Main;
 IMPORT Out;
BEGIN
 Out.String("Казалось бы, при чём тут секция инициализации переменных?"); Out.Ln
END Main.</code></pre>

<p>Исходно в Modula-2 программный модуль выглядел именно так, но библиотечный модуль обозначался как <code>IMPLEMENTATION MODULE</code>, что явно задавало нужный контекст.</p>

<p>В Обероне же была устранены разновидности модулей, а в отношении секции операторов модуля автор, несмотря на минимализм сообщения о языке, был вполне однозначен<a href='#[0]'>[0]</a>:</p>

<blockquote>Модуль — это набор описаний констант, типов, переменных и процедур, а также последовательности операторов, предназначенных для присваивания начальных значений переменным.</blockquote>

<p>Можно, конечно, отмахиваться от желания людей использовать Oberon так, но есть причины, почему это можно и учесть. Главное, что плохо в неявных главных модулях в Обероне — это смешивание понятий, что как показывает опыт, может плохо сказываться на ясности даже для опытных программистов.</p>

<p>Для избежания терминологической путаницы в экспериментальной ветке транслятора Восток сделано небольшое добавление — процедуры верхнего уровня<a href='#[1]'>[1]</a>:</p>

<pre><code>PROCEDURE Go;
 IMPORT Out;
BEGIN
 Out.String("Вроде бы то же самое, но ясности больше."); Out.Ln
END Go.</code></pre>

<p>В продолжении развития идеи можно было бы больше сблизить процедуры верхнего уровня с обычными процедурами и устранить секцию импорта, заменив её автоматическим импортом используемых модулей, но нужно ли?</p>

<h3>Сноски:</h3>
<span id='[0]'>[0]</span> Н.Вирт. Язык программирования Оберон. <a href='https://vostok-space.github.io/Oberon-report/#11.'>Глава 11</a>.<br/>
<span id='[1]'>[1]</span> Пример процедуры верхнего уровня <a href='https://vostok.oberon.org/sandbox.html?view=81sg6pcvzsea-proc'>в песочнице</a>.

</body>
</html>
