<!DOCTYPE html>

<html lang="ru">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Отказы и ошибки</title>

  <link rel="stylesheet" type="text/css" href="../main.css"/>
</head>

<body><h2>Обработка отказов и ошибок</h2>

<div class="separator" style="clear: both;"><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj-9i2eESUoEw4SIoup21xRFGvDnUM9bvav5OA5UvNPrxNPHNA56xaDI3ip6uJ2apmA6NUsU42yS629yftYOvlxo9oNPMQJvegQpnAaIYXEf_I-NLG0E2CVmYGyfuXRrLhcq61pSIhIUb2OZiDZmoH3yNRoblPVHJhwZP4u3ixSAR9ghpqUOCvXxGuKePQ/s1024/DALL%C2%B7E%202024-03-16%2011.29.59%20-%20Illustrate%20a%20note%20about%20error%20handling%20in%20program%20code,%20depicting%20this%20as%20an%20electromechanical%20computer%20from%20which%20a%20line%20of%20bugs%20is%20marching%20out.%20The.webp" style="display: block; padding: 0 1em; text-align: center; clear: right; float: right;"><img alt="" border="0" width="320" data-original-height="1024" data-original-width="1024" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj-9i2eESUoEw4SIoup21xRFGvDnUM9bvav5OA5UvNPrxNPHNA56xaDI3ip6uJ2apmA6NUsU42yS629yftYOvlxo9oNPMQJvegQpnAaIYXEf_I-NLG0E2CVmYGyfuXRrLhcq61pSIhIUb2OZiDZmoH3yNRoblPVHJhwZP4u3ixSAR9ghpqUOCvXxGuKePQ/s320/DALL%C2%B7E%202024-03-16%2011.29.59%20-%20Illustrate%20a%20note%20about%20error%20handling%20in%20program%20code,%20depicting%20this%20as%20an%20electromechanical%20computer%20from%20which%20a%20line%20of%20bugs%20is%20marching%20out.%20The.webp"/></a></div>

<p>Тема правильной обработки отказов и ошибок в программе является довольно сложным вопросом в программировании. Отчасти от того, что и она сама является источником постоянных недоразумений и ошибок проектирования из-за коварной рекурсии в природе ошибок. Другую часть сложностей, как это водится, программисты создают себе сами, вводя ненужную путаницу.</p>

<p>Возникающие при работе кода отказы по своему происхождению можно разделить на:</p>
<ol><li>отказы ввода и вывода <li>ошибки самого кода <li> <i>ошибки исполнителя кода</i></ol>

<p>Ошибки исполнителя, в частности, аппаратные сбои тоже можно учитывать в программном коде, но далеко не всегда это целесообразно из-за сравнительной редкости в типичных условиях. Здесь ошибки исполнителя не рассматриваются. Отказы вывода можно свести к отказам ввода, потому что сведения о неуспешности вывода по сути должны быть введены.</p>

<!--more-->

<style>p {hyphens: auto; text-align:justify;}</style>

<p>Природа отказов ввода и ошибок кода принципиально отличается, как и качества подходов к их обработке. Но между ними есть связь, которая часто приводит к путанице<!--a href='#[0]'>[0]</a-->. Неправильная обработка отказов ввода является разновидностью ошибки программного кода. Некоторые ошибки кода могут привести к дополнительным отказам ввода. В других случаях ввод может быть внутренней частью некоторого кода, из-за чего он не является произвольным, и отказы такого ввода будут проявлением ошибок кода. Наконец, когда вводом программы в том или ином виде тоже является код, то ошибки этого кода оказываются ошибками-отказами ввода для читающей программы. С наиболее широкой точки зрения любой код является результатом ввода. Всё это приводит многих к мысли, что отказы ввода и ошибки кода следует обрабатывать одинаково. Но для получения более надёжных решений нужно избегать смешивания этих понятий.</p>

<style>
  pre, code { background-color: #EBEBEB; overflow: auto; color: black;}
  td {padding: 5px;}
  code i {color:grey;}
  b.err {color:brown;}
  b.inperr {color:green;}
  b.runerr {color:darkred;}
  pre a {float:right;}
</style>

<pre><code><a href="https://vostok.oberon.org/sandbox.html?view=8pgqj7206b42-mistakes">песочница</a>VAR ar: ARRAY 15 OF INTEGER;

PROCEDURE InputError*; VAR i: INTEGER;
BEGIN
 <i>(* отказ ввода происходит во время работы кода, но её причина находится вне его *)</i>
 <b class="inperr">In.Int(i );</b> 
 <i>(* это может быть и отсутствие данных *)</i>
 IF ~In.Done THEN
  Out.String("Число не введено.")
 <i>(* и ошибочность данных относительно предъявляемых к ним требований *)</i>  
 ELSIF (i &lt; 0) OR (i >= LEN(ar)) THEN
  Out.String("Индекс выходит за пределы массива.")
 ELSE
  Out.Int(ar[i], 0)
 END;
 Out.Ln
END InputError;

PROCEDURE CodeMistake*; VAR i: INTEGER;
BEGIN
 <b class='err'>i := -2;</b><i>(* причина ошибки находится внутри самого кода *)</i>
 WHILE i &lt; LEN(ar) DO
  INC(i);
  Out.Int(<b class='runerr'>ar[i]</b>, 0) <i>(* проявление ошибки через обнаружение нарушения правила языка *)</i>
 END
END CodeMistake;

PROCEDURE InputAndCodeError*; VAR i: INTEGER;
BEGIN
 <b class="inperr">In.Int(i );</b>
 <i>(* Ошибка находится внутри кода, но заключается не в наличии ошибочного кода,
    а в отсутствии правильного кода, ответственного за обработку отказов ввода.
    Если отказ при работе кода не произойдёт, то и ошибка кода не проявится. *)</i>
 Out.Int(<b class='runerr'>ar[i]</b>, 0)
END InputAndCodeError;

PROCEDURE LogicalError*; VAR i: INTEGER;
BEGIN
 i := 0;
 <b class="inperr">In.Int(i );</b>
 <i>(* Здесь из-за особенности логики при отказе ввода проявится и ошибка кода,
     что приведёт к неправильному результату, но не выявлению ошибки. *)</i>
 Out.Int(<b>ar[i MOD 10]</b>, 0)
END LogicalError;
</code></pre>

<p>Отказы ввода принципиально неустранимы, потому что в отчуждаемом коде автору неподконтролен ввод, который может отсутствовать или быть произвольным, а код может предъявлять ряд требований к данным, несоблюдение которых и трактуется как ошибка. Отказы ввода в правильном коде должны быть обработаны во время его исполнения. Тогда отказы не приводят к ошибкам кода.</p>

<p>Все ошибки кода, напротив, потенциально устранимы, поскольку код находится в распоряжении разработчика. А сохраняются они в коде в основном потому, что остаются неизвестными. И хотя обнаружить ошибки можно даже без прямого запуска программы, в общем случае эта задача трудно разрешима. Поэтому выявление части ошибок кода может перекладываться на время работы кода (ошибки времени исполнения), а для другой части может отсутствовать полностью (логические ошибки).</p>

<p>Из-за того, что ошибки кода неизвестны, обработать их напрямую, так же, как отказы ввода, невозможно. Их можно лишь косвенно выявлять по их следствиям проверкой проектно неизменных свойств кода (инвариантов). Если свойство не выполняется, то есть не соблюдается его неизменность, значит где-то произошла ошибка кода. Часть таких свойств может быть проверена автоматически, потому что они выводимы из правил самого языка, как, например, нахождение индекса массива в пределах его размера. Проверка другой части может задаваться лишь самим программистом с помощью утверждений (assertions).</p>

<pre><code>TYPE Range = RECORD min, max: INTEGER END;<a href='#[1]'>[1]</a>

PROCEDURE Init*(VAR r: Range; min, max: INTEGER);
BEGIN
  <b>ASSERT(min &lt;= max);</b>
  r.min := min; 
  r.max := max
END Init;</code></pre>

<p>Неизменные свойства кода являются частью или следствием его смысла и только его. Правильно составленные ASSERT не задают эти свойства, а лишь формализуют, вводя жёсткие проверки соответствующих логических выражений.</p>

<p>Проверка в ASSERT не подразумевает дальнейшее выполнение кода в случае обнаружения нарушения заданного условия, но, строго говоря, и не гарантирует прерывание в общем случае <a href='#[2]'>[2]</a>. ASSERT следует применять исключительно для проверки неизменных свойств. Свойства вводимых данных такими не являются и такая их проверка является целенаправленным созданием ошибок кода, что в свою очередь является ошибкой проектирования. Наличие жёстких проверок неизменных свойств не должно подменять собой мягкие проверки произвольных данных.</p>

<pre><code>In.Int(min );
<i>(* Форма проверки входных данных на ошибки может отличаться от 
    проверки неизменных свойств кода в зависимости от контекста *)</i>
IF In.Done &amp; (min &lt;= IntMax - (N-1)) THEN
  Range.Init(r ,  min, min + (N-1))
ELSE
  HandleError
END</code></pre>

<p>В полностью правильном коде при любых входных данных все проверки неизменности свойств оказываются истинными, поэтому программисты любят отключать или даже не включать проверки. Правда, полностью правильный код мало-мальски большого размера составляет исчезающе малую часть от всего используемого кода. В то же время отключение проверок является важной частью тестирования надёжных систем, потому что без такого контроля эффекты поиска и обнаружения ошибок вместе с самими ошибками могут непреднамеренно стать частью основной логики, что вредно<!--a href='#[3]'>[3]</a-->.</p>

<p>Чёткое разделение — жёсткие проверки для неизменных свойств и мягкие для произвольных данных делает удобной отладку кода после АВОСТ (postmortem — посмертная отладка). Только нарушение жёстких проверок, связываемых с ошибками кода, приводит к аварийной остановке, из-за чего она может быть автоматически обработана отладчиком с выдачей нужных сведений. Чем больше будет жёстких проверок как со стороны языка, так и со стороны разработчика, тем легче будет отладка. В случае использования механизма исключений прерывание потока выполнения может быть вызвано как ошибками кода, так и отказами ввода и таким образом быть частью условно «нормального» потока выполнения. Поэтому сложно автоматически обнаружить время и место, когда необходима остановка в отладчике, кроме тех счастливых случаев, когда исключение от ошибки кода не была искажено ни одним из обработчиков исключений. Если же пытаться останавливаться на любых выбросах исключений, то в случае изобилия отказов ввода можно утонуть в спаме.</p>

<p>В тех случаях, когда код часто имеет дело с произвольными данными или содержит проверки, сложно отделимые от основных действий, или сами проверки довольно сложны, может быть удобным сделать основные проверки мягкими. Это позволит применять их как с недоверенными, так и с доверенными данными. В последнем случае достаточно проверять результат таких процедур в ASSERT, ведь свойства проверенных данных относятся к неизменным, и результат их проверки должен быть всегда истинным.</p>

<pre><code>PROCEDURE Init*(VAR r: Range; min, max: INTEGER): BOOLEAN;
VAR ok: BOOLEAN;
BEGIN
  ok := min &lt;= max;
  IF ok THEN r.min := min; r.max := max END
RETURN
  ok
END Init;

...
In.Int(m0 ); In.Int(m1 );
ok := In.Done 
    &amp; Range.Init(r0 , m0, m1);
    
...
<i>(* постоянные параметры являются тривиально доверенными *)</i>
ASSERT(Range.Init(r1 , 20, 40));

In.Int(n);
IF In.Done THEN
  <i>(* хотя n произвольно, ABS(n DIV 2) в этом контексте является доверенным *)</i>
  ASSERT(Range.Init(r2 , 0, ABS(n DIV 2)))
END
</code></pre>

<p>Вызовы процедур, возвращающих правильность своего выполнения в качестве логического значения, удобно связывать в цепочки проверок, что возможно за счёт краткой схемы вычисления логических выражений:</p>
<pre><code>ok := Range.Init(r0 ,  min0, max0)
    &amp; Range.Init(r1 ,  min1, max1)
    &amp; Range.Union(r2 ,  r0, r1);</code></pre>

<p>Если нужны подробности отказа, что характерно при наличии сложных проверок, то всё равно удобней оставить возврат правильности логическим значением. Его учёт удобен и с ним трудней запутаться, а дополнительные сведения можно поместить в отдельный выходной параметр.</p>

<pre><code>TYPE Error* = POINTER TO RECORD(Errors.R) importantDetails*: INTEGER END;

<i>(* mark — метка конкретной ошибки в контексте (под)программы, 
  идентификация по типу записи либо недостаточна, либо ресурсоёмка *)</i>
PROCEDURE ErrorNew(VAR err: Errors.T; mark: INTEGER; details: INTEGER);
VAR e: Error;
BEGIN
 NEW(e );
 <i>(* В неудачном сценарии поток ошибок может перегрузить систему выделения,
    поэтому начализация может подменять объект на предвыделенный без деталей *)</i>
 IF Errors.Init(e , mark, err ) THEN
   e.importantDetails := details
 END
END ErrorNew;

PROCEDURE InitOrErr*(VAR r: Range; min, max: INTEGER; VAR err: Errors.T; mark: INTEGER): BOOLEAN;
BEGIN
  IF min &lt;= max THEN
    r.min := min; r.max := max;
    err := Errors.No
  ELSE
    ErrorNew(err , mark, min DIV 2 + max DIV 2)
  END
RETURN
  err = Errors.No
END InitOrErr;

<i>(*...*)</i>
VAR r0, r1, r2: Range.T; err: Errors.T;
BEGIN 
  ok := Range.InitOrErr(r0 ,  min0, max0,  err , ErrRange0)
      &amp; Range.InitOrErr(r1 ,  min1, max1,  err , ErrRange1)
      &amp; Range.UnionOrErr(r2 ,  r0, r1,     err , ErrUnion);
 <i>(*...*)</i>

  CASE Errors.Mark(err) OF
  | Errors.None: ;
  | Errors.Some: Out.String("Ошибка без подробностей")
  | ErrRange0: Out.String("Неправильные параметры 1-го отрезка: ");
       Out.Int(err(Range.Error).importantDetails, 0)
  | ErrRange1: Out.String("Неправильный 2-й отрезок")
  | ErrUnion: Out.String("Невозможно объединить отрезки")
  END;
  Out.Ln</code></pre>

<p>Если вызываемая процедура не возвращает объект отказа общего типа, потому что для неё это избыточно и нежелательно<a href='#[3]'>[3]</a>, то такой объект всё равно можно создать отдельно, не разрывая цепочки проверки правильности.</p>
<pre><code>PROCEDURE ErrorWrap(VAR err: Errors.T; mark: INTEGER; details: INTEGER): BOOLEAN;
VAR e: Error;
BEGIN
  NEW(e ); IF Errors.Init(e , mark, err ) THEN e.importantDetails := details END
RETURN <i>(* возвращаемое значение нужно только чтобы вписаться в выражение *)</i>
  FALSE
END ErrorWrap;
...

VAR r0, r1, r2: Range.T; err: Errors.T; ierr: INTEGER;
BEGIN
  ok := ( Range.Init(r0 ,  min0, max0,  ierr ) OR ErrorWrap(err , ErrRange0, ierr) )
      &amp; ( Range.Init(r1 ,  min1, max1,  ierr ) OR ErrorWrap(err , ErrRange1, ierr) )
      &amp; ( Range.Union(r2 ,  r0, r1,  ierr )    OR ErrorWrap(err , ErrUnion, ierr) );
</code></pre>

<p>Можно обойтись и без логических выражений, используя многоветочный IF. Этот подход имеет свои достоинства и недостатки.</p>

<pre><code>  IF    ~Range.Init(r0 ,  min0, max0,  ierr ) THEN err := ErrorNew(ErrRange0, ierr)
  ELSIF ~Range.Init(r1 ,  min1, max1,  ierr ) THEN err := ErrorNew(ErrRange1, ierr)
  ELSIF ~Range.Union(r2 ,  r0, r1,  ierr )    THEN err := ErrorNew(ErrUnion, ierr)
  ELSE  err := Errors.No
  END
</code></pre>

<p>Если подробности отказа нужны редко, то закономерно желание составить основную процедуру вообще без выходных параметров для сведений об отказах, заключив их в качестве глобальной переменной в модуле, содержащем процедуру. Это гибкий подход, позволяющий избежать создания разных версий процедур, но теряющий в очевидности, и требующий бо́льшей осторожности<a href='#[4]'>[4]</a>. Но главное, чтобы процедура продолжала явный возврат состояния правильности.</p>

<pre><code><i>(* Когда подробности не нужны *)</i>
  ok := Range.Init(r0 ,  min0, max0)
      &amp; Range.Init(r1 ,  min1, max1)
      &amp; Range.Union(r2 ,  r0, r1);

 VAR err: Errors.T;
 BEGIN
<i>(* Когда подробности необходимы *)</i>
  ok := ( Range.Init(r0 ,  min0, max0) OR Range.Error(err , ErrRange0) )
      &amp; ( Range.Init(r1 ,  min1, max1) OR Range.Error(err , ErrRange1) )
      &amp; ( Range.Union(r2 ,  r0, r1)    OR Range.Error(err , ErrUnion) );

<i>(* Когда нужны не слишком детальные подробности *)</i>
  ok := ( Range.Init(r0 ,  min0, max0)
        &amp; Range.Init(r1 ,  min1, max1)
        &amp; Range.Union(r2 ,  r0, r1)
        )
     OR Range.Error(err , ErrUnion));
</code></pre>

<br/>
<h3>Примечания</h3>
<!--a href='#[0]' id='[0]'>[0]</a> Особенно часто путаница происходит в языках с исключениями, где из-за особенности их обработки нельзя надёжно отличить ошибки кода от ошибок ввода.<br/-->
<a href='#[1]' id='[1]'>[1]</a> Стоит отметить, что применение в ряде языков структурных литералов (значения записей и массивов) вместо процедур инициализации (включая конструкторы), не способствует проверкам правильности при отсутствии дополнительных механизмов.<br/>
<a href='#[2]' id='[2]'>[2]</a> Возможность отсутствия прерывания выполнения кода после ASSERT c ложным условием является расширением по отношению к оригинальной спецификации Oberon-07, в которой лаконично
<a href="https://vostok-space.github.io/Oberon-report/oberon.html#10.2">указано</a>,
что <cite>ASSERT(b) — abort, if ~b</cite><br/>
<a href='#[3]' id='[3]'>[3]</a> Как можно более быстрое отсечение ошибочных ситуаций может быть важно для программ, которые могут быть перегружены ошибочными данными.<br/>
<a href='#[4]' id='[4]'>[4]</a> Подробности отказа в глобальных переменных не подходят также системам с разновидностью <a href="../../2022/11/correct-concurrency.html">многопоточности</a>, несовместимой с однопоточным режимом.<br/>
<br/>

<h3>Дополнительно:</h3>
Ошибки кода можно не только обрабатывать, но и сокращать их количество — <a href='https://comdivbyzero.blogspot.com/2021/11/safety-with-modeling.html'>повышение надёжности по модели проявления ошибок в коде</a>.

</body>
</html>
